@startuml QMP5

class Prenda {
  tipo : TipoDePrenda
  material : Material
  colorPrincipal : Color
  colorSecundario : Color
  trama : Trama
  estado : EstadoPrenda
  usos : Integer

  Categoria getCategoria()
  Boolean esDeCategoria(unaCategoria)
  void validarCategoria(unaCategoria)
  void usar()
}


class Color {
  rojo : int
  verde : int
  azul : int 
}

enum Categoria {
  CALZADO,
  PARTE_SUPERIOR,
  PARTE_INFERIOR,
  ACCESORIO,
}

enum Material {
  ALGODON,
  LINO,
  LANA,
  POLIESTER,
  SEDA,
}

class TipoDePrenda {
  categoria : Categoria  
  
  Categoria getCategoria()
}

Prenda --> Material
Prenda --> TipoDePrenda
Prenda --> Color
TipoDePrenda --> Categoria
' Prenda conoce su Material
' Prenda --> "1" Categoria


enum Trama{
  LISA,
  RAYADA,
  CON_LUNARES,
  A_CUADROS,
  ESTAMPADO,
}

' Trama corresponde a la tela, eso quiere decir que
' corresponde al Material? De ser asi debemos agregarle comportamiento
' al enum de Material creo
' IMO: Hay que agregarlo directamente a la prenda como propiedad
Prenda --> Trama

' El borrador deberia ser una clase "parecida" a la Prenda, e
' incluso dentro de su constructor, podemos hacer las validaciones
' de los datos para crear a la prenda desde alli

class Borrador {
  tipo : TipoDePrenda
  material : Material
  colorPrincipal : Color
  colorSecundario : Color
  trama : Trama

  void cargarMaterial(material)
  void cargarColorPrincipal(colorPrincipal)
  void cargarColorSecundario(colorSecundario)
  void cargarTrama(trama)
  Prenda crearPrenda()
}

class Uniforme {
  parteSuperior : Prenda
  parteInferior : Prenda
  calzado : Prenda
}

Uniforme -->"3" Prenda
Borrador ..> Prenda


class Sugerencia {
  torso : Prenda
  piernas : Prenda
  pies : Prenda
  accesorios : <List>Prenda

  void validarSugerencia(torso, piernas, pies)

}


Sugerencia -> "3..*" Prenda


' Para la segunda parte usamos el patron State

abstract EstadoPrenda {
  Boolean puedeSerSugerida()
  void usar(unaPrenda)
}

class Sucia {
  void lavar()
  Boolean puedeSerSugerida()
  void usar(unaPrenda)
}

class Percudida {
  Boolean puedeSerSugerida()
  void usar(unaPrenda)
}

class Limpia {
  Boolean puedeSerSugerida()
  void usar(unaPrenda)
}

class Lavando {
  Boolean puedeSerSugerida()
  void usar(unaPrenda)
}
' No esta clara la transicion de estado que tiene el estado Lavando
' por lo que decidimos que mientras se esta lavando se pueda usar
' y cuando eso suceda, pasara a Limpia

EstadoPrenda <|-- Sucia
EstadoPrenda <|-- Percudida
EstadoPrenda <|-- Limpia
EstadoPrenda <|-- Lavando

Sucia ..> Percudida
Sucia ..> Lavando
Lavando ..> Limpia
Limpia ..> Sucia

Prenda -right-> EstadoPrenda

class Guardarropas {
  prendas : List<Prenda>
  propuesta : List<Propuesta>

  void aceptarPropuesta(Propuesta)
  void rechazarPropuesta(Propuesta)
  void deshacerPropuesta(Propuesta)
}

' Se consiguen las propuestas existentes con getPropuestas

class Usuario {
  guardarropas : List<Guardarropas>
}

interface Propuesta {
  void aplicarEn(Guardarropas)
}

class Agregar {
  prenda : Prenda
}

class Quitar {
  prenda : Prenda
}

Guardarropas --> "*" Prenda
Usuario --> "*" Guardarropas
Guardarropas -right-> "*" Propuesta

Agregar .down.|> Propuesta
Quitar .down.|> Propuesta

@enduml
